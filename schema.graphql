type Action {
  id: ID!
  actionType: String!
  actor: String!
  primaryCollection: String
  timestamp: BigInt!
  chainId: Int!
  txHash: String!
  numeric1: BigInt
  numeric2: BigInt
  context: String
}

type Transfer {
  id: ID!
  tokenId: BigInt!
  from: String!
  to: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  collection: String!
  chainId: Int!
}

type MintEvent {
  id: ID!
  collectionKey: String!
  tokenId: BigInt!
  minter: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
  encodedTraits: String  # VM-specific: encoded trait data from Minted event
}

type Erc1155MintEvent {
  id: ID!
  collectionKey: String!
  tokenId: BigInt!
  value: BigInt!
  minter: String!
  operator: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type CandiesInventory {
  id: ID!  # contract_tokenId (e.g., "0x80283fbf2b8e50f6ddf9bfc4a90a8336bc90e38f_1")
  contract: String!
  tokenId: BigInt!
  currentSupply: BigInt!  # Cumulative mints
  mintCount: Int!  # Number of mint transactions
  lastMintTime: BigInt
  chainId: Int!
}

type BadgeHolder {
  id: ID!
  address: String!
  chainId: Int!
  totalBadges: BigInt!
  totalAmount: BigInt!
  holdings: Json!
  updatedAt: BigInt!
  badgeBalances: [BadgeBalance!]! @derivedFrom(field: "holder")
  badgesHeld: [BadgeAmount!]! @derivedFrom(field: "holder")
}

type BadgeAmount {
  id: ID!
  holder: BadgeHolder!
  badgeId: String!
  amount: BigInt!
  updatedAt: BigInt!
}

type BadgeBalance {
  id: ID!
  holder: BadgeHolder!
  contract: String!
  tokenId: BigInt!
  chainId: Int!
  amount: BigInt!
  updatedAt: BigInt!
}

type FatBeraDeposit {
  id: ID!
  collectionKey: String!
  depositor: String!
  recipient: String!
  amount: BigInt!
  shares: BigInt!
  transactionFrom: String
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type BgtBoostEvent {
  id: ID!
  account: String!
  validatorPubkey: String!
  amount: BigInt!
  transactionFrom: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type HoneyJar_Approval {
  id: ID!
  owner: String!
  approved: String!
  tokenId: BigInt!
}

type HoneyJar_ApprovalForAll {
  id: ID!
  owner: String!
  operator: String!
  approved: Boolean!
}

type HoneyJar_BaseURISet {
  id: ID!
  uri: String!
}

type HoneyJar_OwnershipTransferred {
  id: ID!
  previousOwner: String!
  newOwner: String!
}

type HoneyJar_SetGenerated {
  id: ID!
  generated: Boolean!
}

type HoneyJar_Transfer {
  id: ID!
  from: String!
  to: String!
  tokenId: BigInt!
}

type Mint {
  id: ID!
  tokenId: BigInt!
  to: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  collection: String!
  chainId: Int!
}

type Holder {
  id: ID!
  address: String!
  balance: Int!
  totalMinted: Int!
  lastActivityTime: BigInt!
  firstMintTime: BigInt
  collection: String!
  chainId: Int!
}

type TrackedHolder {
  id: ID!
  contract: String!
  collectionKey: String!
  chainId: Int!
  address: String!
  tokenCount: Int!
}

type CollectionStat {
  id: ID!
  collection: String!
  totalSupply: Int!
  totalMinted: Int!
  totalBurned: Int!
  uniqueHolders: Int!
  lastMintTime: BigInt
  chainId: Int!
}

type GlobalCollectionStat {
  id: ID!
  collection: String!
  circulatingSupply: Int!
  homeChainSupply: Int!
  ethereumSupply: Int!
  berachainSupply: Int!
  proxyLockedSupply: Int!
  totalMinted: Int!
  totalBurned: Int!
  uniqueHoldersTotal: Int!
  lastUpdateTime: BigInt!
  homeChainId: Int!
}

type Token {
  id: ID!
  collection: String!
  chainId: Int!
  tokenId: BigInt!
  owner: String!
  isBurned: Boolean!
  mintedAt: BigInt!
  lastTransferTime: BigInt!
}

type UserBalance {
  id: ID!
  address: String!
  generation: Int!
  balanceHomeChain: Int!
  balanceEthereum: Int!
  balanceBerachain: Int!
  balanceTotal: Int!
  mintedHomeChain: Int!
  mintedEthereum: Int!
  mintedBerachain: Int!
  mintedTotal: Int!
  lastActivityTime: BigInt!
  firstMintTime: BigInt
}

type Vault {
  id: ID!
  user: String!
  accountIndex: Int!
  honeycombId: BigInt!
  isActive: Boolean!
  shares: BigInt!
  totalBurned: Int!
  burnedGen1: Boolean!
  burnedGen2: Boolean!
  burnedGen3: Boolean!
  burnedGen4: Boolean!
  burnedGen5: Boolean!
  burnedGen6: Boolean!
  createdAt: BigInt!
  closedAt: BigInt
  lastActivityTime: BigInt!
}

type VaultActivity {
  id: ID!
  user: String!
  accountIndex: Int!
  activityType: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  honeycombId: BigInt
  hjGen: Int
  shares: BigInt
  reward: BigInt
}

type UserVaultSummary {
  id: ID!
  user: String!
  totalVaults: Int!
  activeVaults: Int!
  totalShares: BigInt!
  totalRewardsClaimed: BigInt!
  totalHJsBurned: Int!
  firstVaultTime: BigInt
  lastActivityTime: BigInt!
}

# ============================
# HENLO BURN TRACKING MODELS
# ============================

type HenloBurn {
  id: ID!  # tx_hash_logIndex
  amount: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  from: String!  # Address that initiated the burn
  source: String!  # "incinerator", "overunder", "beratrackr", or "user"
  chainId: Int!
}

type HenloBurnStats {
  id: ID!  # chainId_source (e.g., "80084_incinerator" or "80084_total")
  chainId: Int!
  source: String!  # "incinerator", "overunder", "beratrackr", "user", or "total"
  totalBurned: BigInt!
  burnCount: Int!
  uniqueBurners: Int!  # Count of unique addresses for this source on this chain
  lastBurnTime: BigInt
  firstBurnTime: BigInt
}

type HenloGlobalBurnStats {
  id: ID!  # "global"
  totalBurnedAllChains: BigInt!
  totalBurnedMainnet: BigInt!
  totalBurnedTestnet: BigInt!
  burnCountAllChains: Int!
  incineratorBurns: BigInt!
  overunderBurns: BigInt!
  beratrackrBurns: BigInt!
  userBurns: BigInt!
  uniqueBurners: Int!  # Count of unique addresses that have burned at least once (all chains)
  incineratorUniqueBurners: Int!  # Unique addresses that have burned via the incinerator (all chains)
  lastUpdateTime: BigInt!
}

# ============================
# HENLO HOLDER TRACKING MODELS
# ============================

type HenloHolder {
  id: ID!  # address (lowercase)
  address: String!  # Holder address (lowercase)
  balance: BigInt!  # Current balance
  firstTransferTime: BigInt  # First time they received HENLO
  lastActivityTime: BigInt!  # Last transfer activity
  chainId: Int!
}

type HenloHolderStats {
  id: ID!  # chainId (e.g., "80084")
  chainId: Int!
  uniqueHolders: Int!  # Count of addresses with balance > 0
  totalSupply: BigInt!  # Sum of all holder balances
  lastUpdateTime: BigInt!
}

# ============================
# UNIQUE BURNERS MATERIALIZATION
# ============================

type HenloBurner {
  id: ID!            # address (lowercase)
  address: String!   # duplicate of id for convenience
  firstBurnTime: BigInt
  chainId: Int!
}

type HenloSourceBurner {
  id: ID!            # chainId_source_address (e.g., "80084_incinerator_0x...")
  chainId: Int!
  source: String!
  address: String!
  firstBurnTime: BigInt
}

type HenloChainBurner {
  id: ID!            # chainId_address
  chainId: Int!
  address: String!
  firstBurnTime: BigInt
}

# ============================
# AQUABERA WALL TRACKING MODELS
# ============================

type AquaberaDeposit {
  id: ID!  # tx_hash_logIndex
  amount: BigInt!  # Amount of BERA deposited
  shares: BigInt!  # LP tokens received
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  from: String!  # Address that made the deposit
  isWallContribution: Boolean!  # True if from wall contract address
  chainId: Int!
}

type AquaberaWithdrawal {
  id: ID!  # tx_hash_logIndex
  amount: BigInt!  # Amount of BERA withdrawn
  shares: BigInt!  # LP tokens burned
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  from: String!  # Address that made the withdrawal
  chainId: Int!
}

type AquaberaBuilder {
  id: ID!  # user address
  address: String!
  totalDeposited: BigInt!  # Total BERA deposited
  totalWithdrawn: BigInt!  # Total BERA withdrawn
  netDeposited: BigInt!  # Deposited minus withdrawn
  currentShares: BigInt!  # Current LP token balance
  depositCount: Int!
  withdrawalCount: Int!
  firstDepositTime: BigInt
  lastActivityTime: BigInt!
  isWallContract: Boolean!  # True if this is the wall contract address
  chainId: Int!
}

type AquaberaStats {
  id: ID!  # "global" or "chainId" for per-chain stats
  totalBera: BigInt!  # Total BERA in vault
  totalShares: BigInt!  # Total LP tokens
  totalDeposited: BigInt!  # All-time deposits
  totalWithdrawn: BigInt!  # All-time withdrawals
  uniqueBuilders: Int!  # Unique addresses that deposited
  depositCount: Int!
  withdrawalCount: Int!
  wallContributions: BigInt!  # Total BERA from wall contract
  wallDepositCount: Int!  # Number of wall deposits
  lastUpdateTime: BigInt!
  chainId: Int
}

# ============================================================================
# TRADING SYSTEM
# ============================================================================

# Mibera NFT Trade (ERC-721 trades)
type MiberaTrade {
  id: ID!  # tx_hash_logIndex for proposals, tx_hash_offeredTokenId for accept/cancel
  offeredTokenId: BigInt!
  requestedTokenId: BigInt!
  proposer: String!
  acceptor: String  # Null until accepted
  status: String!  # 'active', 'completed', 'cancelled', 'expired'
  proposedAt: BigInt!
  completedAt: BigInt  # Null until completed or cancelled
  expiresAt: BigInt!  # proposedAt + 15 minutes
  txHash: String!
  blockNumber: BigInt!
  chainId: Int!
}

# Cargo/Candies Trade (ERC-1155 trades)
type CandiesTrade {
  id: ID!  # tx_hash_logIndex
  tradeId: BigInt!  # Sequential ID from smart contract
  offeredTokenId: BigInt!
  offeredAmount: BigInt!
  requestedTokenId: BigInt!
  requestedAmount: BigInt!
  proposer: String!
  requestedFrom: String!  # Target user for this trade
  acceptor: String  # Null until accepted
  status: String!  # 'active', 'completed', 'cancelled', 'expired'
  proposedAt: BigInt!
  completedAt: BigInt  # Null until completed or cancelled
  expiresAt: BigInt!  # proposedAt + 15 minutes
  txHash: String!
  blockNumber: BigInt!
  chainId: Int!
}

# Trade statistics
type TradeStats {
  id: ID!  # "global" for all-time stats
  totalMiberaTrades: Int!
  completedMiberaTrades: Int!
  cancelledMiberaTrades: Int!
  expiredMiberaTrades: Int!
  totalCandiesTrades: Int!
  completedCandiesTrades: Int!
  cancelledCandiesTrades: Int!
  expiredCandiesTrades: Int!
  uniqueTraders: Int!  # Count of unique addresses that have traded
  lastTradeTime: BigInt
  chainId: Int
}

# ============================================================================
# SET & FORGETTI VAULT SYSTEM
# ============================================================================

# User's active position in a Set & Forgetti vault (stateful tracking)
# IMPORTANT FIELDS EXPLANATION:
# - totalDeposited & totalWithdrawn: Cumulative lifetime flows of kitchen tokens
#   * Use (totalDeposited - totalWithdrawn) to check if user has net deposits
# - vaultShares: Current unstaked vault shares in user's wallet
# - stakedShares: AGGREGATE of shares staked across ALL MultiRewards for this vault
#   * This is the SUM of all SFMultiRewardsPosition.stakedShares for this user+vault
#   * Does NOT show which MultiRewards contract holds which shares
#   * For per-MultiRewards breakdown, query SFMultiRewardsPosition entities
# - totalShares: Total ownership = vaultShares + stakedShares
type SFPosition {
  id: ID!                     # {chainId}_{user}_{vault}
  user: String!               # User address (lowercase)
  vault: String!              # SFVault address (lowercase)
  multiRewards: String!       # MultiRewards address (lowercase)
  kitchenToken: String!       # Underlying kitchen token address (lowercase)
  strategy: String!           # BeradromeStrategy address (lowercase)
  kitchenTokenSymbol: String! # Token symbol (e.g., "HLKD1B")
  vaultShares: BigInt!        # Current vault shares in user's wallet (not staked)
  stakedShares: BigInt!       # Current staked vault shares in MultiRewards (aggregate across all generations)
  totalShares: BigInt!        # Total shares owned (vaultShares + stakedShares)
  totalDeposited: BigInt!     # Lifetime kitchen tokens deposited into vault (cumulative flow)
  totalWithdrawn: BigInt!     # Lifetime kitchen tokens withdrawn from vault (cumulative flow)
  totalClaimed: BigInt!       # Lifetime HENLO rewards claimed
  firstDepositAt: BigInt!     # Timestamp of first deposit
  lastActivityAt: BigInt!     # Timestamp of most recent activity
  chainId: Int!
}

# Vault-level aggregated statistics (income tracking per pot)
type SFVaultStats {
  id: ID!                     # {chainId}_{vault}
  vault: String!              # SFVault address (lowercase)
  kitchenToken: String!       # Underlying kitchen token address (lowercase)
  kitchenTokenSymbol: String! # Token symbol (e.g., "HLKD1B")
  strategy: String!           # BeradromeStrategy address (lowercase)
  totalDeposited: BigInt!     # All-time kitchen tokens deposited
  totalWithdrawn: BigInt!     # All-time kitchen tokens withdrawn
  totalStaked: BigInt!        # All-time vault shares staked
  totalUnstaked: BigInt!      # All-time vault shares unstaked
  totalClaimed: BigInt!       # All-time HENLO rewards claimed (income metric!)
  uniqueDepositors: Int!      # Count of unique users who have deposited
  activePositions: Int!       # Current count of positions with stakedShares > 0
  depositCount: Int!          # Total number of deposit transactions
  withdrawalCount: Int!       # Total number of withdrawal transactions
  claimCount: Int!            # Total number of claim transactions
  firstDepositAt: BigInt      # Timestamp of first vault deposit
  lastActivityAt: BigInt!     # Timestamp of most recent activity
  chainId: Int!
}

# Tracks user staking in individual MultiRewards contracts
# Linked to SFPosition via user+vault to show breakdown across old/new MultiRewards
# IMPORTANT: This entity tracks PER-MULTIREWARDS positions separately
# - When vaults migrate strategies, new MultiRewards contracts are created
# - Users may have stakedShares > 0 in MULTIPLE MultiRewards for the same vault
# - To identify migration opportunities:
#   1. Query SFMultiRewardsPosition where stakedShares > 0
#   2. Check SFVaultStrategy to see if that multiRewards has activeTo != null (inactive)
#   3. If inactive && stakedShares > 0, user needs to migrate to the new MultiRewards
type SFMultiRewardsPosition {
  id: ID!                     # {chainId}_{user}_{multiRewards}
  user: String!               # User address (lowercase)
  vault: String!              # Vault address this MultiRewards belongs to
  multiRewards: String!       # MultiRewards contract address (lowercase)
  stakedShares: BigInt!       # Current shares staked in THIS specific MultiRewards contract
  totalStaked: BigInt!        # Cumulative shares ever staked in this MultiRewards (lifetime flow)
  totalUnstaked: BigInt!      # Cumulative shares ever unstaked from this MultiRewards (lifetime flow)
  totalClaimed: BigInt!       # HENLO claimed from THIS MultiRewards
  firstStakeAt: BigInt        # First stake timestamp
  lastActivityAt: BigInt!     # Last activity timestamp
  chainId: Int!
}

# Tracks vault strategy versions (for handling strategy migrations)
# Allows historical tracking so old MultiRewards can still be indexed
type SFVaultStrategy {
  id: ID!                     # {chainId}_{vault}_{strategy}
  vault: String!              # SFVault address (lowercase)
  strategy: String!           # Strategy address (lowercase)
  multiRewards: String!       # MultiRewards address (lowercase)
  kitchenToken: String!       # Underlying kitchen token address (lowercase)
  kitchenTokenSymbol: String! # Token symbol (e.g., "HLKD1B")
  activeFrom: BigInt!         # Block timestamp when this strategy became active
  activeTo: BigInt            # Block timestamp when replaced (null if current)
  isActive: Boolean!          # True if this is the current strategy
  chainId: Int!
}

# ============================
# MIBERA STAKING TRACKING
# ============================

type MiberaStakedToken {
  id: ID!  # stakingContract_tokenId (e.g., "paddlefi_123")
  stakingContract: String!  # "paddlefi" or "jiko"
  contractAddress: String!  # 0x242b... or 0x8778... (lowercase)
  tokenId: BigInt!
  owner: String!  # current holder address (lowercase)
  isStaked: Boolean!  # true if currently staked, false if withdrawn
  depositedAt: BigInt!
  depositTxHash: String!
  depositBlockNumber: BigInt!
  withdrawnAt: BigInt  # null if still staked
  withdrawTxHash: String
  withdrawBlockNumber: BigInt
  chainId: Int!
}

type MiberaStaker {
  id: ID!  # stakingContract_address (e.g., "paddlefi_0x123...")
  stakingContract: String!  # "paddlefi" or "jiko"
  contractAddress: String!  # 0x242b... or 0x8778... (lowercase)
  address: String!  # user address (lowercase)
  currentStakedCount: Int!  # Number of tokens currently staked
  totalDeposits: Int!  # All-time deposits
  totalWithdrawals: Int!  # All-time withdrawals
  firstDepositTime: BigInt
  lastActivityTime: BigInt!
  chainId: Int!
}

# ============================
# MIBERA TREASURY MARKETPLACE
# ============================

# ============================
# MIBERA LOAN SYSTEM
# ============================

# Active loans tracking (both backing loans and item loans)
type MiberaLoan @entity {
  id: ID!                      # chainId_loanType_loanId (e.g., "80094_backing_1")
  loanId: BigInt!
  loanType: String!            # "backing" | "item"
  user: String!                # User who took the loan
  tokenIds: [BigInt!]!         # NFT token IDs used as collateral (backing loans have multiple)
  amount: BigInt!              # Loan amount (for backing loans)
  expiry: BigInt!              # Timestamp when loan expires
  status: String!              # "ACTIVE" | "REPAID" | "DEFAULTED"
  createdAt: BigInt!           # Timestamp when loan was created
  repaidAt: BigInt             # Timestamp when repaid (null if active/defaulted)
  defaultedAt: BigInt          # Timestamp when defaulted (null if active/repaid)
  transactionHash: String!
  chainId: Int!
}

# Loan stats aggregate
type MiberaLoanStats @entity {
  id: ID!                      # "80094_global"
  totalActiveLoans: Int!
  totalLoansCreated: Int!
  totalLoansRepaid: Int!
  totalLoansDefaulted: Int!
  totalAmountLoaned: BigInt!
  totalNftsWithLoans: Int!     # Current NFTs being used as collateral
  chainId: Int!
}

# Daily RFV snapshots for historical charting
type DailyRfvSnapshot @entity {
  id: ID!                      # chainId_day (e.g., "80094_19875")
  day: Int!                    # Days since epoch
  rfv: BigInt!                 # RFV value for this day
  timestamp: BigInt!           # Timestamp of when recorded
  chainId: Int!
}

# Collection mint/transfer activity (for activity feed)
type MiberaTransfer @entity {
  id: ID!                      # txHash_logIndex
  from: String!
  to: String!
  tokenId: BigInt!
  isMint: Boolean!             # True if from is zero address
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

# SilkRoad marketplace orders (from CandiesMarket ERC1155)
type MiberaOrder @entity {
  id: ID!                      # chainId_txHash_logIndex
  user: String!                # Buyer address (lowercase)
  tokenId: BigInt!             # Candies token ID purchased
  amount: BigInt!              # Quantity purchased
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

# ============================
# TREASURY MARKETPLACE
# ============================

# Treasury-owned NFT tracking (defaulted/redeemed items available for purchase)
type TreasuryItem {
  id: ID!                      # tokenId as string
  tokenId: BigInt!
  isTreasuryOwned: Boolean!    # true if currently owned by treasury
  acquiredAt: BigInt           # timestamp when treasury acquired it
  acquiredVia: String          # "backing_loan_default" | "item_loan_default" | "redemption"
  acquiredTxHash: String       # transaction that transferred to treasury
  purchasedAt: BigInt          # timestamp when purchased (null if still available)
  purchasedBy: String          # address that purchased (null if available)
  purchasedTxHash: String      # purchase transaction hash
  purchasePrice: BigInt        # RFV + royalty at time of purchase
  chainId: Int!
}

# Treasury aggregate statistics
type TreasuryStats {
  id: ID!                      # "80094_global"
  totalItemsOwned: Int!        # current count of treasury-owned items
  totalItemsEverOwned: Int!    # all-time items acquired
  totalItemsSold: Int!         # all-time items purchased from treasury
  realFloorValue: BigInt!      # current RFV (from RFVChanged event)
  lastRfvUpdate: BigInt        # timestamp of last RFV update
  lastActivityAt: BigInt!      # last event timestamp
  chainId: Int!
}

# Treasury activity event log (for history/feed)
type TreasuryActivity {
  id: ID!                      # txHash_logIndex
  activityType: String!        # "item_acquired" | "item_purchased" | "rfv_updated" | "backing_loan_defaulted"
  tokenId: BigInt              # NFT tokenId (null for RFV updates and backing loan defaults)
  user: String                 # user involved (acquirer or purchaser)
  amount: BigInt               # RFV/price at time of event
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

# ============================
# TRACKED ERC-20 TOKEN BALANCES
# ============================

type TrackedTokenBalance {
  id: ID!  # {address}_{tokenAddress}_{chainId}
  address: String!  # Holder address (lowercase)
  tokenAddress: String!  # Token contract address (lowercase)
  tokenKey: String!  # Human-readable key (e.g., "henlo", "hlkd1b")
  chainId: Int!
  balance: BigInt!  # Current balance
  lastUpdated: BigInt!
}

# ============================
# HENLOCKER VAULT SYSTEM
# ============================

# Vault round (per strike price per epoch)
type HenloVaultRound {
  id: ID!                      # {strike}_{epochId}_{chainId}
  strike: BigInt!              # Strike price
  epochId: BigInt!             # Epoch ID
  exists: Boolean!
  closed: Boolean!
  depositsPaused: Boolean!
  timestamp: BigInt!           # When round was opened
  depositLimit: BigInt!        # Maximum deposit capacity
  totalDeposits: BigInt!       # Total deposited amount
  whaleDeposits: BigInt!       # Deposits from reservoir (whale matching)
  userDeposits: BigInt!        # Regular user deposits
  remainingCapacity: BigInt!   # depositLimit - totalDeposits
  canRedeem: Boolean!          # Can users redeem from this round
  chainId: Int!
}

# Individual deposit record
type HenloVaultDeposit {
  id: ID!                      # {txHash}_{logIndex}
  user: String!                # User address (lowercase)
  strike: BigInt!              # Strike price
  epochId: BigInt!             # Epoch ID
  amount: BigInt!              # Deposit amount
  timestamp: BigInt!           # When deposit occurred
  transactionHash: String!     # Transaction hash
  chainId: Int!
}

# User balance per strike
type HenloVaultBalance {
  id: ID!                      # {user}_{strike}_{chainId}
  user: String!                # User address (lowercase)
  strike: BigInt!              # Strike price
  balance: BigInt!             # Current balance for this strike
  lastUpdated: BigInt!         # Last update timestamp
  chainId: Int!
}

# Epoch-level aggregates
type HenloVaultEpoch {
  id: ID!                      # {epochId}_{chainId}
  epochId: BigInt!             # Epoch ID
  strike: BigInt!              # Associated strike
  closed: Boolean!             # Epoch closed
  depositsPaused: Boolean!     # Deposits paused
  timestamp: BigInt!           # When epoch created
  depositLimit: BigInt!        # Deposit limit
  totalDeposits: BigInt!       # Total user deposits
  reservoir: String!           # Reservoir contract address
  totalWhitelistDeposit: BigInt!  # Whitelist deposit total
  totalMatched: BigInt!        # Matched amounts from reservoir
  chainId: Int!
}

# Global vault statistics (singleton per chain)
type HenloVaultStats {
  id: ID!                      # chainId as string
  totalDeposits: BigInt!       # Sum of all deposits
  totalUsers: Int!             # Count of unique users
  totalRounds: Int!            # Count of rounds created
  totalEpochs: Int!            # Count of epochs created
  chainId: Int!
}

# Tracks unique users who have deposited
type HenloVaultUser {
  id: ID!                      # {user}_{chainId}
  user: String!                # User address (lowercase)
  firstDepositTime: BigInt     # First deposit timestamp
  lastActivityTime: BigInt!    # Last activity timestamp
  chainId: Int!
}

# ============================
# MIBERA PREMINT TRACKING
# ============================

# Individual premint participation event
type PremintParticipation {
  id: ID!                      # txHash_logIndex
  phase: BigInt!               # Premint phase (1, 2, etc.)
  user: String!                # User address (lowercase)
  amount: BigInt!              # Amount contributed
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

# Individual refund event
type PremintRefund {
  id: ID!                      # txHash_logIndex
  phase: BigInt!               # Premint phase
  user: String!                # User address (lowercase)
  amount: BigInt!              # Amount refunded
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

# Aggregate user premint stats
type PremintUser {
  id: ID!                      # user_chainId
  user: String!                # User address (lowercase)
  totalContributed: BigInt!    # Total amount contributed across all phases
  totalRefunded: BigInt!       # Total amount refunded across all phases
  netContribution: BigInt!     # totalContributed - totalRefunded
  participationCount: Int!     # Number of participation events
  refundCount: Int!            # Number of refund events
  firstParticipationTime: BigInt
  lastActivityTime: BigInt!
  chainId: Int!
}

# Per-phase statistics
type PremintPhaseStats {
  id: ID!                      # phase_chainId
  phase: BigInt!
  totalContributed: BigInt!    # Total contributions in this phase
  totalRefunded: BigInt!       # Total refunds in this phase
  netContribution: BigInt!     # Net amount still in phase
  uniqueParticipants: Int!     # Count of unique addresses
  participationCount: Int!     # Total participation events
  refundCount: Int!            # Total refund events
  chainId: Int!
}

# ============================
# FRIEND.TECH KEY TRACKING
# ============================

# Individual trade event (buy or sell)
type FriendtechTrade {
  id: ID!                      # txHash_logIndex
  trader: String!              # Address that made the trade
  subject: String!             # Subject (key) being traded
  subjectKey: String!          # Human-readable key name (e.g., "jani_key")
  isBuy: Boolean!              # true = buy, false = sell
  shareAmount: BigInt!         # Number of shares traded
  ethAmount: BigInt!           # ETH amount for the trade
  supply: BigInt!              # Total supply after trade
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

# Aggregate holder balance per subject
type FriendtechHolder {
  id: ID!                      # subject_trader_chainId
  subject: String!             # Subject address
  subjectKey: String!          # Human-readable key name
  holder: String!              # Holder address
  balance: Int!                # Current key balance (buys - sells)
  totalBought: Int!            # Lifetime keys bought
  totalSold: Int!              # Lifetime keys sold
  firstTradeTime: BigInt       # First trade timestamp
  lastTradeTime: BigInt!       # Last trade timestamp
  chainId: Int!
}

# Per-subject statistics
type FriendtechSubjectStats {
  id: ID!                      # subject_chainId
  subject: String!             # Subject address
  subjectKey: String!          # Human-readable key name
  totalSupply: BigInt!         # Current total supply
  uniqueHolders: Int!          # Count of addresses with balance > 0
  totalTrades: Int!            # Total trade count
  totalBuys: Int!              # Total buy count
  totalSells: Int!             # Total sell count
  totalVolumeEth: BigInt!      # Total ETH volume
  lastTradeTime: BigInt!       # Last trade timestamp
  chainId: Int!
}
