type Action {
  id: ID!
  actionType: String!
  actor: String!
  primaryCollection: String
  timestamp: BigInt!
  chainId: Int!
  txHash: String!
  numeric1: BigInt
  numeric2: BigInt
  context: String
}

type Transfer {
  id: ID!
  tokenId: BigInt!
  from: String!
  to: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  collection: String!
  chainId: Int!
}

type MintEvent {
  id: ID!
  collectionKey: String!
  tokenId: BigInt!
  minter: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type Erc1155MintEvent {
  id: ID!
  collectionKey: String!
  tokenId: BigInt!
  value: BigInt!
  minter: String!
  operator: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type CandiesInventory {
  id: ID!  # contract_tokenId (e.g., "0x80283fbf2b8e50f6ddf9bfc4a90a8336bc90e38f_1")
  contract: String!
  tokenId: BigInt!
  currentSupply: BigInt!  # Cumulative mints
  mintCount: Int!  # Number of mint transactions
  lastMintTime: BigInt
  chainId: Int!
}

type BadgeHolder {
  id: ID!
  address: String!
  chainId: Int!
  totalBadges: BigInt!
  totalAmount: BigInt!
  holdings: Json!
  updatedAt: BigInt!
  badgeBalances: [BadgeBalance!]! @derivedFrom(field: "holder")
  badgesHeld: [BadgeAmount!]! @derivedFrom(field: "holder")
}

type BadgeAmount {
  id: ID!
  holder: BadgeHolder!
  badgeId: String!
  amount: BigInt!
  updatedAt: BigInt!
}

type BadgeBalance {
  id: ID!
  holder: BadgeHolder!
  contract: String!
  tokenId: BigInt!
  chainId: Int!
  amount: BigInt!
  updatedAt: BigInt!
}

type FatBeraDeposit {
  id: ID!
  collectionKey: String!
  depositor: String!
  recipient: String!
  amount: BigInt!
  shares: BigInt!
  transactionFrom: String
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type BgtBoostEvent {
  id: ID!
  account: String!
  validatorPubkey: String!
  amount: BigInt!
  transactionFrom: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  chainId: Int!
}

type HoneyJar_Approval {
  id: ID!
  owner: String!
  approved: String!
  tokenId: BigInt!
}

type HoneyJar_ApprovalForAll {
  id: ID!
  owner: String!
  operator: String!
  approved: Boolean!
}

type HoneyJar_BaseURISet {
  id: ID!
  uri: String!
}

type HoneyJar_OwnershipTransferred {
  id: ID!
  previousOwner: String!
  newOwner: String!
}

type HoneyJar_SetGenerated {
  id: ID!
  generated: Boolean!
}

type HoneyJar_Transfer {
  id: ID!
  from: String!
  to: String!
  tokenId: BigInt!
}

type Mint {
  id: ID!
  tokenId: BigInt!
  to: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  collection: String!
  chainId: Int!
}

type Holder {
  id: ID!
  address: String!
  balance: Int!
  totalMinted: Int!
  lastActivityTime: BigInt!
  firstMintTime: BigInt
  collection: String!
  chainId: Int!
}

type TrackedHolder {
  id: ID!
  contract: String!
  collectionKey: String!
  chainId: Int!
  address: String!
  tokenCount: Int!
}

type CollectionStat {
  id: ID!
  collection: String!
  totalSupply: Int!
  totalMinted: Int!
  totalBurned: Int!
  uniqueHolders: Int!
  lastMintTime: BigInt
  chainId: Int!
}

type GlobalCollectionStat {
  id: ID!
  collection: String!
  circulatingSupply: Int!
  homeChainSupply: Int!
  ethereumSupply: Int!
  berachainSupply: Int!
  proxyLockedSupply: Int!
  totalMinted: Int!
  totalBurned: Int!
  uniqueHoldersTotal: Int!
  lastUpdateTime: BigInt!
  homeChainId: Int!
}

type Token {
  id: ID!
  collection: String!
  chainId: Int!
  tokenId: BigInt!
  owner: String!
  isBurned: Boolean!
  mintedAt: BigInt!
  lastTransferTime: BigInt!
}

type UserBalance {
  id: ID!
  address: String!
  generation: Int!
  balanceHomeChain: Int!
  balanceEthereum: Int!
  balanceBerachain: Int!
  balanceTotal: Int!
  mintedHomeChain: Int!
  mintedEthereum: Int!
  mintedBerachain: Int!
  mintedTotal: Int!
  lastActivityTime: BigInt!
  firstMintTime: BigInt
}

type Vault {
  id: ID!
  user: String!
  accountIndex: Int!
  honeycombId: BigInt!
  isActive: Boolean!
  shares: BigInt!
  totalBurned: Int!
  burnedGen1: Boolean!
  burnedGen2: Boolean!
  burnedGen3: Boolean!
  burnedGen4: Boolean!
  burnedGen5: Boolean!
  burnedGen6: Boolean!
  createdAt: BigInt!
  closedAt: BigInt
  lastActivityTime: BigInt!
}

type VaultActivity {
  id: ID!
  user: String!
  accountIndex: Int!
  activityType: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  honeycombId: BigInt
  hjGen: Int
  shares: BigInt
  reward: BigInt
}

type UserVaultSummary {
  id: ID!
  user: String!
  totalVaults: Int!
  activeVaults: Int!
  totalShares: BigInt!
  totalRewardsClaimed: BigInt!
  totalHJsBurned: Int!
  firstVaultTime: BigInt
  lastActivityTime: BigInt!
}

# ============================
# HENLO BURN TRACKING MODELS
# ============================

type HenloBurn {
  id: ID!  # tx_hash_logIndex
  amount: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  from: String!  # Address that initiated the burn
  source: String!  # "incinerator", "overunder", "beratrackr", or "user"
  chainId: Int!
}

type HenloBurnStats {
  id: ID!  # chainId_source (e.g., "80084_incinerator" or "80084_total")
  chainId: Int!
  source: String!  # "incinerator", "overunder", "beratrackr", "user", or "total"
  totalBurned: BigInt!
  burnCount: Int!
  uniqueBurners: Int!  # Count of unique addresses for this source on this chain
  lastBurnTime: BigInt
  firstBurnTime: BigInt
}

type HenloGlobalBurnStats {
  id: ID!  # "global"
  totalBurnedAllChains: BigInt!
  totalBurnedMainnet: BigInt!
  totalBurnedTestnet: BigInt!
  burnCountAllChains: Int!
  incineratorBurns: BigInt!
  overunderBurns: BigInt!
  beratrackrBurns: BigInt!
  userBurns: BigInt!
  uniqueBurners: Int!  # Count of unique addresses that have burned at least once (all chains)
  incineratorUniqueBurners: Int!  # Unique addresses that have burned via the incinerator (all chains)
  lastUpdateTime: BigInt!
}

# ============================
# HENLO HOLDER TRACKING MODELS
# ============================

type HenloHolder {
  id: ID!  # address (lowercase)
  address: String!  # Holder address (lowercase)
  balance: BigInt!  # Current balance
  firstTransferTime: BigInt  # First time they received HENLO
  lastActivityTime: BigInt!  # Last transfer activity
  chainId: Int!
}

type HenloHolderStats {
  id: ID!  # chainId (e.g., "80084")
  chainId: Int!
  uniqueHolders: Int!  # Count of addresses with balance > 0
  totalSupply: BigInt!  # Sum of all holder balances
  lastUpdateTime: BigInt!
}

# ============================
# UNIQUE BURNERS MATERIALIZATION
# ============================

type HenloBurner {
  id: ID!            # address (lowercase)
  address: String!   # duplicate of id for convenience
  firstBurnTime: BigInt
  chainId: Int!
}

type HenloSourceBurner {
  id: ID!            # chainId_source_address (e.g., "80084_incinerator_0x...")
  chainId: Int!
  source: String!
  address: String!
  firstBurnTime: BigInt
}

type HenloChainBurner {
  id: ID!            # chainId_address
  chainId: Int!
  address: String!
  firstBurnTime: BigInt
}

# ============================
# AQUABERA WALL TRACKING MODELS
# ============================

type AquaberaDeposit {
  id: ID!  # tx_hash_logIndex
  amount: BigInt!  # Amount of BERA deposited
  shares: BigInt!  # LP tokens received
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  from: String!  # Address that made the deposit
  isWallContribution: Boolean!  # True if from wall contract address
  chainId: Int!
}

type AquaberaWithdrawal {
  id: ID!  # tx_hash_logIndex
  amount: BigInt!  # Amount of BERA withdrawn
  shares: BigInt!  # LP tokens burned
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
  from: String!  # Address that made the withdrawal
  chainId: Int!
}

type AquaberaBuilder {
  id: ID!  # user address
  address: String!
  totalDeposited: BigInt!  # Total BERA deposited
  totalWithdrawn: BigInt!  # Total BERA withdrawn
  netDeposited: BigInt!  # Deposited minus withdrawn
  currentShares: BigInt!  # Current LP token balance
  depositCount: Int!
  withdrawalCount: Int!
  firstDepositTime: BigInt
  lastActivityTime: BigInt!
  isWallContract: Boolean!  # True if this is the wall contract address
  chainId: Int!
}

type AquaberaStats {
  id: ID!  # "global" or "chainId" for per-chain stats
  totalBera: BigInt!  # Total BERA in vault
  totalShares: BigInt!  # Total LP tokens
  totalDeposited: BigInt!  # All-time deposits
  totalWithdrawn: BigInt!  # All-time withdrawals
  uniqueBuilders: Int!  # Unique addresses that deposited
  depositCount: Int!
  withdrawalCount: Int!
  wallContributions: BigInt!  # Total BERA from wall contract
  wallDepositCount: Int!  # Number of wall deposits
  lastUpdateTime: BigInt!
  chainId: Int
}

# ============================================================================
# TRADING SYSTEM
# ============================================================================

# Mibera NFT Trade (ERC-721 trades)
type MiberaTrade {
  id: ID!  # tx_hash_logIndex for proposals, tx_hash_offeredTokenId for accept/cancel
  offeredTokenId: BigInt!
  requestedTokenId: BigInt!
  proposer: String!
  acceptor: String  # Null until accepted
  status: String!  # 'active', 'completed', 'cancelled', 'expired'
  proposedAt: BigInt!
  completedAt: BigInt  # Null until completed or cancelled
  expiresAt: BigInt!  # proposedAt + 15 minutes
  txHash: String!
  blockNumber: BigInt!
  chainId: Int!
}

# Cargo/Candies Trade (ERC-1155 trades)
type CandiesTrade {
  id: ID!  # tx_hash_logIndex
  tradeId: BigInt!  # Sequential ID from smart contract
  offeredTokenId: BigInt!
  offeredAmount: BigInt!
  requestedTokenId: BigInt!
  requestedAmount: BigInt!
  proposer: String!
  requestedFrom: String!  # Target user for this trade
  acceptor: String  # Null until accepted
  status: String!  # 'active', 'completed', 'cancelled', 'expired'
  proposedAt: BigInt!
  completedAt: BigInt  # Null until completed or cancelled
  expiresAt: BigInt!  # proposedAt + 15 minutes
  txHash: String!
  blockNumber: BigInt!
  chainId: Int!
}

# Trade statistics
type TradeStats {
  id: ID!  # "global" for all-time stats
  totalMiberaTrades: Int!
  completedMiberaTrades: Int!
  cancelledMiberaTrades: Int!
  expiredMiberaTrades: Int!
  totalCandiesTrades: Int!
  completedCandiesTrades: Int!
  cancelledCandiesTrades: Int!
  expiredCandiesTrades: Int!
  uniqueTraders: Int!  # Count of unique addresses that have traded
  lastTradeTime: BigInt
  chainId: Int
}
